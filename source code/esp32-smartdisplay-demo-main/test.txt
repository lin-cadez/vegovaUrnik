void refreshDisplFunction(void *param)
{
  lv_screen_load(ui_startup);
  uint32_t lv_last_tick_local = millis();
  uint32_t lastUrnikRefresh = 0;
  uint32_t lastClockUpdate = 0;

  for (;;)
  {
    uint32_t now = millis();
    lv_tick_inc(now - lv_last_tick_local);
    lv_last_tick_local = now;
    lv_timer_handler();
    bool isScrolling = (lv_indev_get_scroll_obj(lv_indev_get_next(NULL)) != NULL);

    if (appState.wifiConnected && urnikReady && lv_scr_act() == ui_startup)
    {
      syncUiState();
      setText(ui_StUcilnice, st_ucilnice);
      lv_screen_load(ui_main);
      uiLvglState = appState;
      updateUrnik();
      lastUrnikRefresh = now;
      lv_obj_clear_flag(lv_scr_act(), LV_OBJ_FLAG_SCROLLABLE);

      // Nastavi container pravilno
      lv_obj_set_scrollbar_mode(ui_timetableContainer, LV_SCROLLBAR_MODE_OFF);
      lv_obj_set_scroll_snap_y(ui_timetableContainer, LV_SCROLL_SNAP_NONE);
      lv_obj_clear_flag(ui_timetableContainer, LV_OBJ_FLAG_SCROLL_ELASTIC);

      // KLJUÄŒNO: nastavi scroll throw da je bolj odziven
      lv_obj_set_style_anim_time(lv_scr_act(), 200, 0);
    }

    if (lv_scr_act() != ui_startup)
    {
      // Update clock every second
      if (now - lastClockUpdate >= 1000)
      {
        syncAndUpdateTime();
        lastClockUpdate = now;
      }
      bool needsUpdate = false;
      xSemaphoreTake(dataMutex, portMAX_DELAY);
      needsUpdate = appState.dirty;
      xSemaphoreGive(dataMutex);
      if (needsUpdate)
      {
        syncUiState();
        updateUrnik();
      }
      // Refresh timetable every 30 minutes
      if (now - lastUrnikRefresh >= 1UL * 10UL * 1000UL)
      {
        Serial.println("Time to refresh urnik");
        syncUiState();
        syncAndUpdateTime();
        updateUrnik();
        lastUrnikRefresh = now;
      }
    }

    vTaskDelay(isScrolling ? pdMS_TO_TICKS(5) : pdMS_TO_TICKS(20));
  }
}